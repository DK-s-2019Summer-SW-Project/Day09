// 포인터와 배열의 관계 --> 배열의 이름도 pointer이다! 
// 배열 이름의 포인터 형을 이해해 보자. --> 배열의 이름은 포인터이다. 단 , 그 값을 바꿀 수 없는 '상수 형태의 포인터'이다.

#include <stdio.h>
#define _CRT_SECURE_NO_WARNNINGS
// 상수 형태의 포인터에 대한 예제
int main()
{
	int arr[3] = { 0, 1, 2 };
	printf("the name of array: %p\n", arr);
	printf("the first number is: %p\n", &arr[0]); // 참고로 주소를 가져다 쓰기 때문에 &를 붙여 주어야 한다. %p는 주소값의 출력에 사용되는 서식 문자이다.
	printf("the second number is: %p\n", &arr[1]);
	printf("the third number is: %p\n", &arr[2]);
	// arr = &arr[i] --> 이 문장은 에러를 발생 시킨다. 

	// int형 배열 요소간 주소 값의 차는 4바이트 이다.
	// 배열의 이름은 배열의 시작 주소 값을 가르키며, 그 형태는 값의 저장이 불가능한 상수이다.
	// 배열의 이름이란 배열을 일컫는 방법이다! intA[5];로 정의 한다면 A는 int 5개를 모두 나타내는 이름이다!
	// 포인터 변수 --> 이름이 존재, 무엇을 나타내서나 저장이 가능, 주소 값의 변경 또한 가능! --> 말 그대로 변수이기 때문에 주소의 변경이 가능하다!
	// 배열의 이름 --> 이름이 존재, 무엇을 나타내거나 저장이 가능, 주소 값의 변경이 불가능 하다!! --> 이름의 주소는 변경이 불가능하다!
	// 배열의 이름 또한 포인터이기 때문에 배열의 이름을 피연사자로 하는 *연산이 가능하다. --> pointer의 type에 따라서 *연산의 결과가 달라진다! 
	return 0;
}

/*  1차원 배열 이름의 포인터 형과 배열 이름을 대상으로 하는 *연산  */
// int arr1[5]; --> int형 배열이다
// double arr2[10] --> doubel형 배열이다
// 1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정 하면 된다!!
// Example

int main()
{
	int arr1[3] = { 1, 2, 3 };
	double arr2[3] = { 1.1, 2.2, 3.3 };

	printf("%d %g\n", *arr1, *arr2);
	*arr1 += 10;
	*arr2 += 120.5;
	printf("%d %g\n", arr1[0], arr2[0]);


	return 0;
}
// 포인터를 배열의 이름처럼 사용 할 수도 있다!
// 배열의 이름과 포인터 변수는 변수냐 상수냐의 특성적 차이가 있을 뿐, 둘다 pointer이기 때문에 포인터 변수로 할 수 있는 연산은 배열의 이름으로도 할 수 있고, 배열의 이름으로 할 수 있는 연산은 포인터 변수로도 할 수 있다.

int main()
{
	int arr[3] = { 15, 25, 35 };
	int *ptr = &arr[0]; // int *ptr = arr; 와 동일한 코드이다! --> 이게 포인터를 배열의 이름처럼 만들어 놓은 것!

	printf("%d %d\n", ptr[0], arr[0]);
	printf("%d %d\n", ptr[1], arr[1]);
	printf("%d %d\n", ptr[2], arr[2]);

	return 0;
}

// 참고로 위 예제처럼 포인터 변수를 배열의 이름처럼 사용하는 경우는 거의 없다. 
// 마찬가지로 배열의 이름을 포인터 변수처럼 사용하는 경우도 거의 없다. 하지만 이러한 일이 가능하다는 사실을 있어야 한다! --> pointer를 이해하는데 중요하기 때문!!